<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
    <script>

            var camera         = undefined, 
                scene          = undefined, 
                renderer       = undefined, 
                light          = undefined,
                mouseX         = undefined, 
                mouseY         = undefined,
                gameState      = undefined,

            // Box2D shortcuts
                b2World        = Box2D.Dynamics.b2World,
                b2FixtureDef   = Box2D.Dynamics.b2FixtureDef,
                b2BodyDef      = Box2D.Dynamics.b2BodyDef,
                b2Body		   = Box2D.Dynamics.b2Body,
                b2CircleShape  = Box2D.Collision.Shapes.b2CircleShape,
                b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
                b2Settings     = Box2D.Common.b2Settings,
                b2Vec2         = Box2D.Common.Math.b2Vec2,

            // Box2D world variables 
                wWorld         = undefined,
                wBall          = undefined;

            
            function createPhysicsWorld() {
                // Create the world object.
                wWorld = new b2World(new b2Vec2(0, 0), true);

                // Create the ball.
                var bodyDef = new b2BodyDef();
                bodyDef.type = b2Body.b2_dynamicBody;
                bodyDef.position.Set(1, 1);
                wPlayer = wWorld.CreateBody(bodyDef);
                var fixDef = new b2FixtureDef();
                fixDef.density = 1.0;
                fixDef.friction = 0.0;
                fixDef.restitution = 0.25;
                fixDef.shape = new THREE.CubeGeometry(1,1,0,);
                wPlayer.CreateFixture(fixDef);

                // Create the maze.
                bodyDef.type = b2Body.b2_staticBody;
                fixDef.shape = new b2PolygonShape();
                fixDef.shape.SetAsBox(0.5, 0.5);
                for (var i = 0; i < maze.dimension; i++) {
                    for (var j = 0; j < maze.dimension; j++) {
                        if (maze[i][j]) {
                            bodyDef.position.x = i;
                            bodyDef.position.y = j;
                            wWorld.CreateBody(bodyDef).CreateFixture(fixDef);
                        }
                    }
                }
            }
            
            
            function generate_maze_mesh(field) {
                var dummy = new THREE.Geometry();
                for (var i = 0; i < field.dimension; i++) {
                    for (var j = 0; j < field.dimension; j++) {
                        if (field[i][j]) {
                            var geometry = new THREE.CubeGeometry(1,1,1,1,1,1);
                            var mesh_ij = new THREE.Mesh(geometry);
                            mesh_ij.position.x = i;
                            mesh_ij.position.y = j;
                            mesh_ij.position.z = 0.5;
                            THREE.GeometryUtils.merge(dummy, mesh_ij);
                        }
                    }
                }
                var material = new THREE.MeshPhongMaterial({map: brickTexture});
                var mesh = new THREE.Mesh(dummy, material)
                return mesh;
            }


            function createRenderWorld() {

                // Create the scene object.
                scene = new THREE.Scene();

                // Add the light.
                light= new THREE.PointLight(0xffffff, 1);
                light.position.set(1, 1, 1.3);
                scene.add(light);
                
                // Add the ball.
                g = new THREE.SphereGeometry(ballRadius, 32, 16);
                m = new THREE.MeshPhongMaterial({map:ironTexture});
                playerMesh = new THREE.Mesh(g, m);
                playerMesh.position.set(1, 1, 0);
                scene.add(playerMesh);

                // Add the camera.
                var aspect = window.innerWidth/window.innerHeight;
                camera = new THREE.PerspectiveCamera(60, aspect, 1, 1000);
                camera.position.set(1, 1, 5);
                scene.add(camera);

                // Add the terrain.
                levelMesh = generate_level_mesh(level);
                scene.add(levelMesh);

                // Add the ground.
                g = new THREE.PlaneGeometry(levelDimension*10, levelDimension*10, levelDimension, levelDimension);
                planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
                planeTexture.repeat.set(levelDimension*5, levelDimension*5);
                m = new THREE.MeshPhongMaterial({map:planeTexture});
                planeMesh = new THREE.Mesh(g, m);
                planeMesh.position.set((levelDimension-1)/2, (levelDimension-1)/2, 0);
                planeMesh.rotation.set(Math.PI/2, 0, 0);
                scene.add(planeMesh);                

            }


            function updatePhysicsWorld() {

                // Apply "friction". 
                var lv = wPlayer.GetLinearVelocity();
                lv.Multiply(0.95);
                wPlayer.SetLinearVelocity(lv);
                
                // Apply user-directed force.
                var f = new b2Vec2(keyAxis[0]*wPlayer.GetMass()*0.25, keyAxis[1]*wPlayer.GetMass()*0.25);
                wPlayer.ApplyImpulse(f, wPlayer.GetPosition());          
                keyAxis = [0,0];

                // Take a time step.
                wWorld.Step(1/60, 8, 3);
            }
            

            function updateRenderWorld() {

                // Update ball position.
                var stepX = wPlayer.GetPosition().x - playerMesh.position.x;
                var stepY = wPlayer.GetPosition().y - playerMesh.position.y;
                playerMesh.position.x += stepX;
                playerMesh.position.y += stepY;

            }


            function gameLoop() {
            
                switch(gameState) {
                
                    case 'initialize':
                        maze = generateSquareMaze(mazeDimension);
                        maze[mazeDimension-1][mazeDimension-2] = false;
                        createPhysicsWorld();
                        createRenderWorld();
                        camera.position.set(1, 1, 5);
                        light.position.set(1, 1, 1.3);
                        light.intensity = 0;
                        var level = Math.floor((mazeDimension-1)/2 - 4);
                        $('#level').html('Level ' + level);
                        gameState = 'fade in';
                        break;
                        
                    case 'fade in':
                        light.intensity += 0.1 * (1.0 - light.intensity);
                        renderer.render(scene, camera);
                        if (Math.abs(light.intensity - 1.0) < 0.05) {
                            light.intensity = 1.0;
                            gameState = 'play'
                        }
                        break;

                    case 'play':
                        updatePhysicsWorld();
                        updateRenderWorld();
                        renderer.render(scene, camera);

                        // Check for victory.
                        var mazeX = Math.floor(ballMesh.position.x + 0.5);
                        var mazeY = Math.floor(ballMesh.position.y + 0.5);
                        if (mazeX == mazeDimension && mazeY == mazeDimension - 2) { 
                            mazeDimension += 2;
                            gameState = 'fade out';
                        }
                        break;
                
                    case 'fade out':
                        updatePhysicsWorld();
                        updateRenderWorld();
                        light.intensity += 0.1 * (0.0 - light.intensity);
                        renderer.render(scene, camera);
                        if (Math.abs(light.intensity - 0.0) < 0.1) {
                            light.intensity = 0.0;
                            renderer.render(scene, camera);
                            gameState = 'initialize'
                        }
                        break;
                        
                }
            
                requestAnimationFrame(gameLoop);

            }


            function onResize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
            }
            

            function onMoveKey(axis) {
                keyAxis = axis.slice(0);
            }

            
            jQuery.fn.centerv = function () {
                wh = window.innerHeight;
                h = this.outerHeight();
                this.css("position", "absolute");
                this.css("top", Math.max(0, (wh - h)/2) + "px");
                return this;
            }            

            
            jQuery.fn.centerh = function () {
                ww = window.innerWidth;
                w = this.outerWidth();
                this.css("position", "absolute");
                this.css("left", Math.max(0, (ww - w)/2) + "px");
                return this;
            }            

            
            jQuery.fn.center = function () {
                this.centerv();
                this.centerh();
                return this;
            }            

            
            $(document).ready(function() {

                // Prepare the instructions.
                $('#instructions').center();
                $('#instructions').hide();
                KeyboardJS.bind.key('i', function(){$('#instructions').show()}, 
                                         function(){$('#instructions').hide()});
    
                // Create the renderer.
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Bind keyboard and resize events.
                KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
                KeyboardJS.bind.axis('h', 'l', 'j', 'k', onMoveKey);
                $(window).resize(onResize);
                

                // Set the initial game state.
                gameState = 'initialize';
                
                // Start the game loop.
                requestAnimationFrame(gameLoop);

            })
            
            

        </script>
</head>
<body>
    <div class="floor"></div>
    <canvas id="canvas"></canvas>
    <script src="script.js"></script>
</body>
</html>
